{"pageProps":{"tag":"golang","posts":[{"slug":"2025-07-31-go-features","title":"Go features by version","summary":"A summary of which major features appeared in which versions of Go","dateString":"2025-07-31","tags":["golang"],"content":"\nWant to keep updated with the latest golang features? \n\nCheck this: https://antonz.org/which-go/"},{"slug":"2024-11-27-monstache","title":"Monstache","summary":"A tool to stream data from mongodb to elasticsearch","dateString":"2024-11-27","tags":["tools","elasticsearch","mongodb","golang"],"content":"\nThere was a requirement here to stream data from [mongodb](https://www.mongodb.com/) to [Elasticsearch](https://www.elastic.co/), and I decided to research the existing tools.\n\nWe could use [elasticsearch-river-mongodb](https://github.com/richardwilly98/elasticsearch-river-mongodb/wiki), [implement a stream process in node](https://medium.com/@amulyakashyap09/stream-mongodb-to-elasticsearch-using-node-js-755b407eb744), some payed solutions... then I found [monstache](https://rwynn.github.io/monstache-site/) - a stream implementation in golang.\n\n## The good parts\n\n- Monstache is just a single binary without dependencies on runtimes like Ruby, Python or PHP - a [scratch image](https://hub.docker.com/_/scratch) should do the work\n- It does accept [transformations](https://rwynn.github.io/monstache-site/advanced/#transformation) - working sample [here](https://github.com/adamatti/learn-monstache/commit/51ab57c1be5adb3b60555a74838e49c50ffa05d4)\n- [Mappings](https://rwynn.github.io/monstache-site/advanced/#index-mapping) - working sample [here](https://github.com/adamatti/learn-monstache/commit/5ff11d50148354a28c8e027c7935fa0129607013)\n- [Versioning](https://rwynn.github.io/monstache-site/advanced/#indexing-metadata)? - working sample [here](https://github.com/adamatti/learn-monstache/commit/9768a64a0e12ac4c0926049b6731c377013df9bc)\n- Fetch references? check [embedding documents](https://rwynn.github.io/monstache-site/advanced/#embedding-documents)\n- A lot of mongo/elastic [configurations](https://rwynn.github.io/monstache-site/config) - e.g. replay, resume, resume-strategy\n- The [docker image](https://hub.docker.com/layers/rwynn/monstache/6.7.17/images/sha256-a275e45f20e2f2e64f30140479469b1241be340cd81ac5641ac391edcb1d092f?context=explore) is less than 15 mb (compressed size)\n\n## Ok, how can I make it faster?\n\nFrom [the docs](https://rwynn.github.io/monstache-site/advanced/#middleware):\n\n> It is HIGHLY recommended to use a golang plugin in production over a javascript plugin due to performance differences. Currently, golang plugins are orders of magnitude faster than javascript plugins. This is due to concurrency and the need to perform locking on the javascript environment. Javascript plugins are very useful for quickly prototyping a solution, however at some point it is recommended to convert them to golang plugins\n\nFor a golang working sample, check [my repo](https://github.com/adamatti/learn-monstache/commit/ae4d813485246f284d4583c4712a4adfaa94d44c)\n\n## The bad parts\n\nIt uses [streams](https://x.com/baptistejamin/status/1615310358528376832), and it seems it is not performant as using oplog ([ref](https://jira.mongodb.org/browse/SERVER-46979))\n\n## Conclusion\n\nI would give it a try and perform additional performance tests prior to go to prod.\n\nIt is nice it does support [multiple workers](https://rwynn.github.io/monstache-site/advanced/#workers), [High Availability](https://rwynn.github.io/monstache-site/advanced/#high-availability), etc\n\nIt has almost 9yrs since [first commit](https://github.com/rwynn/monstache/commit/04c590bf0896330405eeb12614aba1fc8e570fba), [1.3k starts on github](https://github.com/rwynn/monstache), [videos on youtube](https://www.youtube.com/results?search_query=monstache+elastic)\n\n## References\n\n- [Monstache Github Repo](https://github.com/rwynn/monstache)\n- [Monstache Website/Documentation](https://rwynn.github.io/monstache-site/)\n- [Github - my working sample](https://github.com/adamatti/learn-monstache)\n- [A docker compose with all you need](https://github.com/rwynn/monstache-showcase/blob/master/docker-compose.sc.yml)\n- [Step by Step how to create a golang plugin](https://github.com/rwynn/monstache/wiki/Go-plugin-guide)\n"},{"slug":"2024-04-18-taskfile","title":"Taskfile - an alternative for Makefiles","summary":"A 5 minutes tutorial","dateString":"2024-04-18","tags":["javascript","typescript","tools","golang"],"content":"\nOk, Make/Makefiles are great. I spoke about then in the [last post](/blog/posts/2024-04-08-makefile).\n\nBut what if:\n\n- I want to break them in different files\n- Use a better syntax (maybe yaml?)\n- Cache the tasks, even the ones that don't generate artifacts (e.g. lint)\n- put tasks and aliases close\n- validate the task execution\n- have global tasks to run in any folder (e.g. backup)\n- dry run\n- watch task\n\n#### Taskfile to rescue\n\nJust need to [install Task](https://taskfile.dev/installation/) (or go-task on [github](https://github.com/go-task/task)).\n\nThe [documentation](https://taskfile.dev/) is pretty simple IMHO, but I want to highlight some things that I do use in daily bases that I think it does a great difference.\n\n## Show me the code\n\nFor this I will use the sample from [previous post](/blog/posts/2024-04-08-makefile) ([makefile here](https://github.com/adamatti/node-sample/blob/main/Makefile))\n\n```yaml\n# yaml-language-server: $schema=https://json.schemastore.org/taskfile.json\n---\nversion: '3'\n\nenv:\n  DATABASE_URL: postgres://postgres:sample@localhost:5432/sample\n\nincludes:\n  docker-compose:\n    aliases: [dc]\n    taskfile: ./Taskfile-docker-compose.yaml\n  prisma:\n    aliases: [p]\n    taskfile: ./Taskfile-prisma.yaml\n\ntasks:\n  default:\n    desc: Show help\n    aliases: [h]\n    silent: true\n    cmds:\n      - task -l --sort alphanumeric\n\n  clean:\n    desc: Remove node modules\n    aliases: [c]\n    cmds:\n      - rm -rf node-modules\n\n  install:\n    desc: Install dependencies\n    aliases: [i]\n    run: once\n    cmds:\n      - npm install\n    preconditions:\n      - test -f package.json\n      - test -f package-lock.json\n    sources:\n      - package.json\n      - package-lock.json\n    status:\n      - test -d node_modules\n\n  run-only:\n    aliases: [ro]\n    interactive: true\n    ignore_error: true\n    dotenv: ['.env']\n    cmds:\n      - task: install\n      - task: prisma:generate\n      - npx --yes esno src/index.ts\n\n  run:\n    desc: Run the project\n    aliases: [r]\n    cmds:\n      - task: docker-compose:up\n      - task: prisma:push\n      - task: run-only\n```\n\nThere are a lot of things going on here, so trying to explain some things:\n\n1. The first line is just for auto complete on IDEs (like vscode, zed)\n2. We can define global env vars in the script itself (e.g. `DATABASE_URL`)\n3. We can [import](https://taskfile.dev/usage/#including-other-taskfiles) part of the scripts. You just need to have your global ones (e.g. terraform, docker-compose, prisma, git, etc). It does work with remote files.\n4. You can expose/hide tasks with [internal flag](https://taskfile.dev/usage/#internal-tasks)\n\n## Now the best part - cache\n\nPay a close look on the install task.\n\n1. it only runs if `package.json` and `package-lock.json` are present ([programatic checks](https://taskfile.dev/usage/#using-programmatic-checks-to-cancel-the-execution-of-a-task-and-its-dependencies))\n2. [Prevent unnecessary work](https://taskfile.dev/usage/#prevent-unnecessary-work): it caches the execution using the `source` attribute.\n3. at the end it checks if the `node_modules` folder was created.\n4. Even caching based on the `source`, if you remove the `node_modules` folder (check) it will run again.\n\nSo, you just need to run your daily tasks (e.g. tests, lints, run local) and the script itself will detect what is pending and run it if needed.\n\nNo more crazy issues that you forgot to update a dependency or database change.\n\n## Ok, show me a normal day of work\n\nAt the first time, you just need to run `task r` to run the app. It will install dependencies, start database, apply db changes and run the app.\n\nBut what happen if someone changes a dependency? No problem. Taskfile will detect and will run `npm install` again.\n\nBut if someone just changes the db schema? No problem. It will generate the classes again.\n\nIf nothing changes, it will just run the app (ok, the docker part is not optimized, but you got the idea).\n\nIf need to stop the app and run again you can go direct to `task ro` (ro = run only).\n\n## Full Project\n\nAs always, the full sample is available on [github](https://github.com/adamatti/node-sample).\n\n## Closing thoughts\n\nNow go to the [documentation](https://taskfile.dev/usage/).\n\nRemove commands from `README.md` files and confluence/sharepoint. Also remove it from anemic `package.json` ðŸ˜›\n\nMy global taskfiles are shared [here](https://github.com/adamatti/dotfiles/tree/main/taskfile) for reference.\n\nMy backup scripts using rsync are also on taskfiles, but this is a subject for another post.\n"}]},"__N_SSG":true}